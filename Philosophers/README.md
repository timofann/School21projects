# Dinning philosophers problem

[Полное описание](https://github.com/timofann/School21projects/new/main/Philosophers#общий-принцип-работы)

Mandatory part compilation and run:

    cd philo
    make
    ./philo

Bonus part compilation and run:

    cd philo_bonus
    make
    ./philo_bonus

Arguments for turning in:

- **number_of_philosophers**: The number of philosophers and also the number of forks.
- **time_to_die** (in milliseconds): If a philosopher didn’t start eating time_to_die milliseconds since the beginning of their last meal or the beginning of the sim- ulation, they die.
- **time_to_eat** (in milliseconds): The time it takes for a philosopher to eat. During that time, they will need to hold two forks.
- **time_to_sleep** (in milliseconds): The time a philosopher will spend sleeping.
- **number_of_times_each_philosopher_must_eat** (optional argument): If all philosophers have eaten at least number_of_times_each_philosopher_must_eat times, the simulation stops. If not specified, the simulation stops when a philosopher dies.

## Overview

One or more philosophers sit at a round table. There is a large bowl of spaghetti in the middle of the table.  
The philosophers alternatively **eat**, **think**, or **sleep**. While they are eating, they are not thinking nor sleeping; while thinking, they are not eating nor sleeping;
and, of course, while sleeping, they are not eating nor thinking.  
There are also **forks** on the table. There are **as many forks as philosophers**. Because serving and eating spaghetti with only one fork is very inconvenient, a
philosopher takes their right and their left forks to eat, one in each hand.  
When a philosopher has finished eating, they put their forks back on the table and start sleeping. Once awake, they start thinking again. The simulation stops when a philosopher dies of starvation.  
Every philosopher needs to eat and should never starve.  
Philosophers don’t speak with each other. Philosophers don’t know if another philosopher is about to die.  

**No need to say that philosophers should avoid dying.**

## Mandatory part rules

1. Each philosopher should be a thread.
2. There is one fork between each pair of philosophers. Therefore, if there are several philosophers, each philosopher has a fork on their left side and a fork on their right side. If there is only one philosopher, there should be only one fork on the table.
3. To prevent philosophers from duplicating forks, you should protect the forks state with a mutex for each of them.

## Bonus part rules

1. All the forks are put in the middle of the table.
2. They have no states in memory but the number of available forks is represented by a semaphore.
3. Each philosopher should be a process. But the main process should not be a philosopher.

## Общий принцип работы

Один или несколько философов сидят за круглым столом. В центре стола стоит большая миска со спагетти.  
Философы либо **едят**, либо **думают** либо **спят**. Во время еды они не думают и не спят, во время размышлений они не едят и не спят, и, очевидно, во время сна они не едят и не думают.  
На столе разложены **вилки**. Вилок **столько же, сколько философов**. Поскольку есть спагетти только одной вилкой очень неудобно, философ берет для еды правую и левую вилки, по одной в каждую руку.  
Когда философ заканчивает есть, он кладет свои вилки обратно на стол и засыпает. Проснувшись, он снова начинает думать. Симуляция прекращается, когда один из философов умирает от голода.  
Каждый философ должен есть и никогда не должен голодать, иначе он умрет, и симуляция остановится.  
Философы не разговаривают друг с другом. Философы не знают, не собирается ли кто-то из остальных философов умереть.

**Философы должны жить так долго, насколько это только возможно.**

На вход подаются 4 обязательных и один опциональный аргументы:
- **number_of_philosophers**: Количество философов/вилок.
- **time_to_die** (в миллисекундах): Если философ не начинает есть через **time_to_die** миллисекунд с начала своего последнего приема пищи или с начала симуляции, он умирает.
- **time_to_eat** (в миллисекундах): Время, затрачиваемое на прием пищи. В течение этого времени философу нужно держать две вилки.
- **time_to_sleep** (в миллисекундах): Время, отведенное на сон.
- **number_of_times_each_philosopher_must_eat** (опционально): Если каждый философ поест по крайней мере **number_of_times_each_philosopher_must_eat** раз, симуляция останавливается. Если аргумент не указан, симуляция прекращается, когда один из философов умирает.


Существует файл `main.c`, с функцией main, запускающей функции, разбросанные по одноименным файлам. Такая общепринятая система хранения данных позволяет лучше ориентироваться в проекте и быстрее находить нужные участки кода. Отдельной подструктурой являются инструменты для вывода ошибок и завершения программы, определенные в отдельных заголовочных файлах `philo_error.h` и `philo_bonus_error.h`

В проекте охвачен один из видов межпроцессорного взаимодействия (IPC) - синхронизация. Синхронизация реализуется в UNIX-системах с помощью взаимных исключений (mutex), условных переменных (conditional variables) блокировок чтения-записи и семафоров.  

Выполнить основную часть проекта нужно ограничившись мьютексами, регулирующими поведение потоков одного процесса. Важно уделить им внимание в рамках знакомства с IPC, так как они используются при организации взаимодействия процессов.  Для успешного выполнения бонусной части проекта необходимо использовать семафоры - видимо, знакомство с ними и является главной целью - однако, разрешено использовать любые дополнительные функции, библиотеки и заголовочные файлы, а также дан намек на использование дополнительных потоков для управления процессами (можно рассматривать это как некоторую оптимизацию философов, экономящую для них время жизни).

#### Основная часть (./philo)

В основной части проекта предлагается разработать програму, симулирующую поедание спагетти философами. 
Философы здесь являются **потоками**, имеющими общее адресное пространство, они работают с общими друг для друга данными.

Необходимо организовать работу потоков таким образом, чтобы избежать гонки данных. 
Для этого в проекте испльзуются posix мьютексы (`pthread_mutex_init`, `pthread_mutex_destroy`, `pthread_mutex_lock`, `pthread_mutex_unlock`). 
В мьютекс обернуто, например, обращение потоков к флагу `alive`, инициализированному в главном потоке. 
Этот флаг устанавливается равным 0 в случае, если один из философов умирает. 
Таким образом, главный поток может сообщить философам о том, что кто-то погиб, напрямую между философами информация не передается.

Структура данных о каждом отдельном философе хранится в отдельно выделенной памяти. 
Таким образом, философы могут делить между собой только те области памяти, на которые в структуре имеются ссылки. 
Это список мьютексов-вилок, мьютекс на печать в стандартный вывод (необходим для создания очереди на печать и прекращения печати в случае смерти одного 
из философов), мьютекс на общую переменную `alive` и саму переменную `alive`.

Но есть еще одно уязвимое место в проекте. 
Главный поток в течение жизненных циклов философов постоянно мониторит время последнего приема пищи для каждого из них, а также количество приемов пищи.
Эти переменные изменяются лишь в дополнительных потоках, но может возникнуть ситуация, когда главный поток обратился к переменной, чтобы узнать, не умер ли еще философ от голода, а философ сразу же начал есть. 
Расчет интервала голодания начинает производиться уже после обновления переменной, и интервал получается больше ожидаемого. Поэтому на обращение к этим двум 
переменным (время последнего приема пищи, количество приемов пищи) также добавлены мьютексы, индивидуальные для каждого философа.


#### Бонусная часть (./philo_bonus)

Принципиальное отличие бонусной части - использование процессов в качестве философов. В качестве вилок используется семафор.

Теперь мы не можем использовать общую память и мониторим состояние философов только по `exit_status` дочерних процессов в родительском процессе. 
0 - философ наелся,  1 - философ умер (другой доступный подход - отправка сигналов SIGUSR1 и SIGUSR2). При этом постоянный мониторинг состояния 
процесса (количества приемов пищи и времени пследнего приема пищи) и выход из процесса осуществляются в дополнительных потоках, индивидуальных 
для каждого философа (для снижения нагрузки на жизненный цикл философа и улучшения работоспособности программы).

Создание дочерних процессов снимает обязанность по разделению участков памяти для философов. Теперь разделение реализуется использованием функции `fork`. 
Индивидальная информация назначается философам во время создания новых процессов, что сказывается на работоспособности симуляции, а точнее на 
накоплении задержки включения в симуляцию новых философов. Некоторая задержка в основной части так же есть и она накапливается, это связано с 
постоянным созданием очередей на обращение к переменным и невозможностью моментального выполнения таких операций как печать статуса философа в 
стандартный вывод. Но в основной части эта задержка значительно меньше.

В проекте осуществлена дополнительная логика выхода по нажатию сочетания Ctrl + C. Сигнал SIGINT перехватывается и дублируется для всех дочерних 
процессов, семафоры отключаются.

#### Дополнительно

В процессе выполнения проекта выяснилось, что `usleep` работает на macOS с некоторой погрешностью, критичной для работы программы. 
`usleep` здесь обернут в проверку истечения заданного интервала времени.

Для проверки правильности работы с потоками и отсутствия гонки данных была использована утилита `clang ThreadSanitizer`. 
В основной части ошибок не выявлено. При проверке бонусной части возикает предупреждение неизвестной природы и работа утилиты аварийно завершается. 
Возможно, есть некоторые ограничения на использование при провеке множества процессов.

Кейс 4 200 100 100: Философы должны жить бесконечно долго, потому что они меняются вилками каждые 100 миллисекунд: сначала едят нечетные философы, 
затем четные. Однако на практике из-за возникновения задержек один из философов довольно быстро погибает. Рабочим будет кейс 4 210 100 100, такого 
времени (210 миллисекунд) хватит для смены вилок и приемов пищи с учетом задержек. Возможно, на других системах программа будет работать лучше или хуже, 
и запас времени на смену вилок придется подкорректировать.

Если философов нечетное количество, то для бесперебойного симулирования их жизни необходимо, чтобы параметр `time_to_die` был равен или больше суммы 2ух 
временных интервалов приема пищи и интервала для сна. Последний нечетный философ не сможет поесть одновременно с остальными нечетными философами 
и будет ждать. А последний четный философ будет соответственно, ждать всех нечетных философов и последнего нечетного. Он умрет, если ему не хватит 
времени.

Для визуализации симуляции можно перейти по [ссылке](https://nafuka11.github.io/philosophers-visualizer/).


